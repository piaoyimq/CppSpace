// queue.h -- class template for the Array implementation of a Queue// The constructor, the (default) copy constructor, the (default) assignment operator,// and the enqueue function can throw exceptions if there is no more heap memory.#include "Array.h"template <class DataType>class Queue{public:  	Queue( );	void enqueue( DataType element );	// dequeues element and returns it in deqElement	// returns false if called on an empty queue; otherwise returns true	bool dequeue( DataType & deqElement );  	// returns the front element in frontElement without removing it	// returns false if called on an empty queue; otherwise returns true	bool peek( DataType & frontElement );	bool isEmpty( ) const;		// returns true if queue is empty					// otherwise returns false	void makeEmpty( );private:	Array<DataType> elements;	int front;	int back;};template <class DataType>Queue<DataType>::Queue( )    : elements( 2 ), front( -1 ), back( -1 ){}template <class DataType>void Queue<DataType>::enqueue( DataType element ){	if ( back + 1 == front || ( back == elements.length( ) - 1 && !front ) ) {		elements.changeSize( elements.length( ) << 1 );		// if front end was last part of array, readjust		if ( back < front ) {			int i = elements.length( ) - 1;			for ( int j = ((i + 1) >> 1) - 1; j >= front; i--, j-- )				elements[ i ] = elements[ j ];			front = i + 1;			}		}	if ( back == -1 ) // queue is empty		front = 0;	back = (back == elements.length( ) - 1)? 0 : back + 1;	elements[ back ] = element;}// dequeues element and returns it in deqElement// returns false if called on an empty queue; otherwise returns truetemplate <class DataType>bool Queue<DataType>::dequeue( DataType & deqElement ){	if (front == -1 )		return false;	deqElement = elements[ front ];	if ( front == back ) // only one element was in queue		front = back = -1;	else		front = (front == elements.length( ) - 1)? 0 : front + 1;	// try to reduce the size of the array	int trysize = elements.length( );	int numElements = (front <= back)? back - front + 1 : back + trysize - front + 1;	while ( ( numElements <= trysize >> 2 ) && trysize > 2 )		trysize >>= 1;	if ( trysize < elements.length( ) ) {		// readjust so we won't lose elements when shrinking the array size		int i, j;		if ( front > back ) {			for ( i = trysize - 1, j = elements.length( ) - 1; j >= front; i--, j-- )				elements[ i ] = elements[ j ];			front = i + 1;			try {				elements.changeSize( trysize );			}			catch( ... ) {		        for ( i = elements.length( ) - 1, j = trysize - 1; j >= front; i--, j-- )					elements[ i ] = elements[ j ];                front = i + 1;			    }			return true;			}		else if ( front <= back && back >= trysize ) {			for ( i = 0, j = front; j <= back; i++, j++ )				elements[ i ] = elements[ j ];			front = 0;			back = i - 1;			}		try {			elements.changeSize( trysize );		   }		catch( ... ) { }		}	return true;}// returns the front element in frontElement without removing it// returns false if called on an empty queue; otherwise returns truetemplate <class DataType>bool Queue<DataType>::peek( DataType & frontElement ){	if (front == -1 )		return false;	frontElement = elements[ front ];	return true;}template <class DataType>bool Queue<DataType>::isEmpty( ) const{	return front == -1;}template <class DataType>void Queue<DataType>::makeEmpty( ){	front = back = -1;	try {		elements.changeSize( 2 );	}	catch( ... ) { }}