
#ifndef MUTEX_H_
#define MUTEX_H_

#include <pthread.h>
#include <string>
#include <algorithm>
#include <cerrno>

#include "../Common.h"
#include "ILockable.h"
#include "Lock.h"
#include "NonCopyable.h"


namespace Concurrency
{
//extern pthread_mutex_t singletonMutex;
pthread_mutex_t singletonMutex = PTHREAD_MUTEX_INITIALIZER;


// Purpose:
// To provide a high level OO-abstraction for a standard POSIX mutex (pthread_mutex_t)
//
// Description:
//
// See manual for POSIX mutex:
// * pthread_mutex_create
// * pthread_mutex_lock
// * etc..
//
class Mutex : public ILockable, public NonCopyable
{
    // Autogenerated from the TraceableClass stereotype
private:

public:

    typedef Lock ScopedLock;

    ////    Constructors and destructors    ////

    ////    Operations    ////


    ////    Constructors and destructors    ////

    explicit Mutex();

    ~Mutex();

    ////    Operations    ////

    inline bool lock()
    {
        const int res = pthread_mutex_lock(&mutex_);

        switch (res)
        {
            case 0:      // Mutex was successfully taken
                return true;

            case EDEADLK:
                // TODO: Add statistics counter
                return false;

            default:
                std::cout << "Failed to lock mutex, res: " << res << ", errno: " << strerror(errno) << std::endl;
                ABORT();
                return false;
        }
    }


private:

    pthread_mutex_t mutex_;

public:

    inline void unlock()
    {
        int res;

        if ((res = pthread_mutex_unlock(&mutex_)) != 0)
        {
            std::ostringstream ss;
            switch (res)
            {
                case EPERM:
                    ss << "EPERM (" << res << ")";
                    break;
                default:
                    ss <<  "UNKNOWN (" << res << ")";
                    break;
            }

            std::cout << "pthread_mutex_unlock failed! res: " << ss.str() << std::endl;
        }

    }

    pthread_mutex_t* getMutex();

    // Try to lock the mutex, returns true if it was actually locked, false if another thread already locked it.
    inline bool trylock();
};


// Purpose:
// To provide one single system global mutex
//
class SingletonMutex
{
public:

    class ScopedLock
    {
    public:

        explicit ScopedLock();

        ~ScopedLock();

    private:

        // No dynamic allocation allowed, this would defeat the purpose
        void* operator new(size_t size);

        // No dynamic allocation allowed, this would defeat the purpose
        void* operator new[](size_t size);
    };

    ~SingletonMutex();

    inline static void lock();

    inline static void unlock();

private:

    explicit SingletonMutex();


public:

    static GsnTrace trace_;
};

inline bool Mutex::trylock()
{
    const int res = pthread_mutex_trylock(&mutex_);

    if (res != 0)
    {
        // EBUSY if another thread has locked it, EDEADLK if we have locked it ourselves in our own thread
        if (res == EBUSY || res == EDEADLK)
        {
            return false;
        }
        else
        {
            std::cout << "Failed to try lock mutex, res: " << res << ", errno: " << Errno(errno) << std::endl;
            ABORT();
        }
    }

    return true;
}

inline void SingletonMutex::lock()
{
    // When debugging deadlock situations, turn on trace on libsupport.Mutex.GtlDebug to verify that its actually a deadlock
    std::cout << "Attempting to lock singletonMutex: ..." << std::endl;
    const int res = pthread_mutex_lock(&singletonMutex);


    switch (res)
    {
        case 0:      // Mutex was successfully taken
            std::cout << "... Successfully locked singletonMutex" << std::endl;
            break;

        case EDEADLK:
            // TODO: Add statistics counter
            std::cout << "... singletonMutex lock failed, already owned by calling thread" << std::endl;
            break;

        default:
            std::cout << "Failed to lock mutex, res: " << res << ", errno: " << strerror(errno) << std::endl;
            ABORT();
    }
}

inline void SingletonMutex::unlock()
{
    int res;

    if ((res = pthread_mutex_unlock(&singletonMutex)) != 0)
    {
        std::ostringstream ss;
        switch (res)
        {
            case EPERM:
                ss << "EPERM (" << res << ")";
                break;
            default:
                ss <<  "UNKNOWN (" << res << ")";
                break;
        }

        std::cout << "pthread_mutex_unlock failed! res: " << ss.str() << std::endl;
    }
    else
    {
        std::cout << "Unlocked singletonMutex" << std::endl;
    }
}
}

#endif
/*-------------------------------------------------------------------------------------------------------------------*/
