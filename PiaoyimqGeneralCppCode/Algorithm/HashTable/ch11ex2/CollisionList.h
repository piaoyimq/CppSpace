// CollisionList.h -- class for a linked list as a data structuretemplate <class DataType>struct Node {	DataType info;	Node<DataType> *next;	Node<DataType> *dlnext;	Node<DataType> *dlback;};// CollisionList maintains a current position in list after each function call// If an object of a struct is used for DataType, the == operator must be // overloaded for it; the left and right operands are both DataType objects// the == comparison is used for finding elements, usually by key value// For find, retrieve and remove functions, if you are using an object as an element, a // typical use would be to set the key of the desired object to find or remove, then pass // the object into the function.// The constructor, copy constructor, overloaded assignment operator, and insert function// can throw an exception if out of heap memory.template <class DataType>class CollisionList{public:	CollisionList( );	CollisionList( const CollisionList<DataType> & aplist );	~CollisionList( );	CollisionList<DataType> & operator =( const CollisionList<DataType> & rlist );	void insert( const DataType & element ); // current position is inserted node	bool first( DataType & listEl );	  // returns first element of list in listEl										  // and current position is set to this element; 										  // if list is empty, returns false and there is										  // no current position; otherwise, returns true	inline bool getNext( DataType & listEl );	  // retrieves the next element of a linked list										  // beyond the last element that was retrieved										  // by first or getNext functions and returns										  // it in listEl;										  // current position is set to this element.										  // if no element exists at this position, 										  // getNext returns false and there is no 										  // current position; returns true otherwise		bool find ( const DataType & element );  // returns true if element is found									      // returns false if element is not found										  // if found, found element becomes current										  // position in list; if not found, there is										  // no current position	bool retrieve( DataType & element );  // like find, except returns found element	bool replace( const DataType & newElement ); // replaces element at current position 											   // in list with newElement; returns false if											  // there is no current position (no list 											// modification occurs); returns true otherwise 	bool remove( DataType & element );    // returns true if element is found										  // returns false if element is not found										  // if found, element is set to found element;										  // no current position after use	bool isEmpty( ) const;				  // returns true if linked list is empty										  // returns false otherwise; current position										  // unchanged	void makeEmpty( );					  // no current position	Node<DataType> *getcurrent( ) const;  // retrieves current pointerprivate:	Node<DataType> *start;	Node<DataType> *current;			  // points to node at current position		inline void deepCopy( const CollisionList<DataType> & original );};#include <iostream>using namespace std;template <class DataType>CollisionList<DataType>::CollisionList( ){	start = current = NULL;}template <class DataType>CollisionList<DataType>::CollisionList( const CollisionList<DataType> & aplist ){	deepCopy( aplist );}template <class DataType>CollisionList<DataType>::~CollisionList( ){	makeEmpty( );}template <class DataType>CollisionList<DataType> & CollisionList<DataType>::operator =( const CollisionList<DataType> & rlist ){	if ( this == &rlist )		return *this;	makeEmpty( );	deepCopy( rlist );	return *this;}// inserts at the beginning of the linked list// the current position will be the inserted nodetemplate <class DataType>void CollisionList<DataType>::insert( const DataType & element ){	Node<DataType> *newNode = new Node<DataType>;	newNode->info = element;	newNode->next = start;	current = start = newNode;}// returns first element of list in listEl and current position is set to this element;// if list is empty, returns false and there is no current position;// otherwise, returns truetemplate <class DataType>bool CollisionList<DataType>::first( DataType & listEl ){	if ( start == NULL )		return false;	current = start;	listEl = start->info;	return true;}// retrieves the next element of a linked list beyond the last element that was retrieved// by first or getNext functions and returns it in listEl;// current position is set to this element.// if no element exists at this position, getNext returns false and there is no// current position; returns true otherwisetemplate <class DataType>inline bool CollisionList<DataType>::getNext( DataType & listEl ){	if ( current == NULL )		return false;	if ( current->next == NULL ) {		current = NULL;		return false;		}	current = current->next;	listEl = current->info;	return true;}// returns true if element is found; returns false if element is not found// if found, found element becomes current position in list;// if not found, there is no current positiontemplate <class DataType>bool CollisionList<DataType>::find( const DataType & element ){	DataType item;	if ( !first( item ) )		return false;	do if ( item == element )			return true;	while ( getNext( item ) );	return false;}// returns true if element is found; returns false if element is not found// if found, found element becomes current position in list;// if not found, there is no current positiontemplate <class DataType>bool CollisionList<DataType>::retrieve( DataType & element ){	if ( !find( element ) )		return false;	element = current->info;	return true;}// replaces element at current position in list with newElement;// returns false if there is no current position (no list modification occurs);// returns true otherwisetemplate <class DataType>bool CollisionList<DataType>::replace( const DataType & newElement ){	if ( current == NULL )		return false;	current->info = newElement;	return true;}// returns true if element is found; returns false if element is not found// if found, element is set to found element;// no current position after usetemplate <class DataType>bool CollisionList<DataType>::remove( DataType & element ){	current = NULL;	if ( start == NULL )		return false;	Node<DataType> *ptr = start;	if ( ptr->info == element ) {		element = ptr->info;		start = start->next;		delete ptr;		return true;		}	while ( ptr->next != NULL ) {		if ( ptr->next->info == element ) {			Node<DataType> *tempPtr = ptr->next;			element = tempPtr->info;			ptr->next = tempPtr->next;			delete tempPtr;			return true;			}		ptr = ptr->next;		}	return false;}template <class DataType>bool CollisionList<DataType>::isEmpty( ) const{	return start == NULL;}template <class DataType>void CollisionList<DataType>::makeEmpty( ){	while ( start != NULL ) {		current = start;		start = start->next;		delete current;	}	current = NULL;}template <class DataType>inline void CollisionList<DataType>::deepCopy( const CollisionList<DataType> & original ){	start = current = NULL;	if ( original.start == NULL )		return;	Node<DataType> *copyptr = start = new Node<DataType>;	Node<DataType> *originalptr = original.start;	copyptr->info = originalptr->info;	if ( originalptr == original.current )		current = copyptr;	while ( originalptr->next != NULL ) {		originalptr = originalptr->next;		copyptr->next = new Node<DataType>;		copyptr = copyptr->next;		copyptr->info = originalptr->info;		if ( originalptr == original.current )			current = copyptr;	}	copyptr->next = NULL;}template <class DataType>Node<DataType> *CollisionList<DataType>::getcurrent( ) const{	return current;}