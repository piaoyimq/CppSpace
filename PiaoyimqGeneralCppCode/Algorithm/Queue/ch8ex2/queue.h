// queue.h -- class template for the linked list implementation of a queue// note:  use of the copy constructor, overloaded assignment operator, or enqueue function// can cause an exception to be thrown when heap memory is exhaustedtemplate <class DataType>struct Node {	DataType info;	Node<DataType> *next;};template <class DataType>class Queue{public:	Queue( );	Queue( const Queue<DataType> & apqueue ); 	~Queue( );	Queue<DataType> & operator =( const Queue<DataType> & rqueue );	void enqueue( const DataType & element );		// dequeues element and returns it in deqElement	// returns false if called on an empty queue; otherwise returns true	bool dequeue( DataType & deqElement );	// returns element at the front of the queue into frontElement without removing it	// returns false if called on an empty queue; otherwise returns true	bool peek( DataType & frontElement );  		bool isEmpty( ) const;		// returns true if queue is empty					// otherwise returns false	void makeEmpty( );private:	Node<DataType> *front;	Node<DataType> *back;	Node<DataType> header;	inline void deepCopy( const Queue<DataType> & original );};template <class DataType>Queue<DataType>::Queue( ){	front = back = &header;}template <class DataType>Queue<DataType>::Queue( const Queue<DataType> & apqueue ){	deepCopy( apqueue );}template <class DataType>Queue<DataType>::~Queue( ){	makeEmpty( );}template <class DataType>Queue<DataType> & Queue<DataType>::operator =( const Queue<DataType> & rqueue ){	if ( this == &rqueue )		return *this;	makeEmpty( );	deepCopy( rqueue );	return *this;}template <class DataType>void Queue<DataType>::enqueue( const DataType & element ){	Node<DataType> *ptr = new Node<DataType>;	ptr->info = element;	back->next = ptr;	back = ptr;}// dequeues element and returns it in deqElement// returns false if called on an empty queue; otherwise returns truetemplate <class DataType>bool Queue<DataType>::dequeue( DataType & deqElement ){	if ( front == back )		return false;	Node<DataType> *ptr = front->next;	deqElement = ptr->info;	front->next = ptr->next;	if ( back == ptr )		back = front;	delete ptr;	return true;}// returns element at the front of the queue into frontElement without removing it// returns false if called on an empty queue; otherwise returns truetemplate <class DataType>bool Queue<DataType>::peek( DataType & frontElement ){	if ( front == back )		return false;	frontElement = front->next->info;	return true;}template <class DataType>bool Queue<DataType>::isEmpty( ) const{   	 return front == back;}template <class DataType>void Queue<DataType>::makeEmpty( ){   	DataType temp;	while ( dequeue( temp ) );}template <class DataType>inline void Queue<DataType>::deepCopy( const Queue<DataType> & original ){	Node<DataType> *copyptr = front = &header;	Node<DataType> *originalptr = original.front;	while ( originalptr != original.back ) {		originalptr = originalptr->next;		copyptr->next = new Node<DataType>;		copyptr = copyptr->next;		copyptr->info = originalptr->info;	}	back = copyptr;}